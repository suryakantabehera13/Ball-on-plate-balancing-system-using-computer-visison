# -*- coding: utf-8 -*-
"""bnp_controller.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sXyqKl07rHKMkzY9KO3sq_n8PCPakkio
"""



import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import uniform_filter1d

# Load data from a text file
def load_positions(file_path):
    with open(file_path, 'r') as file:
        positions = [tuple(map(int, line.strip().strip('()').split(','))) for line in file.readlines()]
    return np.array(positions)

# Velocity consistency
def calculate_velocities(positions):
    velocities = np.sqrt(np.sum(np.diff(positions, axis=0)**2, axis=1))
    return velocities

# Smoothness evaluation
def smooth_positions(positions, window_size=5):
    smoothed_positions = uniform_filter1d(positions, size=window_size, axis=0)
    errors = np.sqrt(np.sum((positions - smoothed_positions)**2, axis=1))
    return smoothed_positions, errors

# Relative error within clusters
def calculate_mse(positions):
    cluster_center = np.mean(positions, axis=0)
    mse = np.mean(np.sum((positions - cluster_center)**2, axis=1))
    return mse

# Visualization
def plot_trajectory(positions, smoothed_positions):
    plt.figure(figsize=(10, 6))
    plt.plot(positions[:, 0], positions[:, 1], label='Detected Trajectory', marker='o', linestyle='-', alpha=0.7)
    plt.plot(smoothed_positions[:, 0], smoothed_positions[:, 1], label='Smoothed Trajectory', linestyle='--', color='orange')
    plt.legend()
    plt.xlabel('X Position (pixels)')
    plt.ylabel('Y Position (pixels)')
    plt.title('Ball Trajectory')
    plt.grid(True)
    plt.show()

# Boundary checks (plate dimensions assumed to be 440x440 pixels for a square plate)
def check_boundaries(positions, plate_width=440, plate_height=440):
    x_within_bounds = np.all((positions[:, 0] >= 0) & (positions[:, 0] <= plate_width))
    y_within_bounds = np.all((positions[:, 1] >= 0) & (positions[:, 1] <= plate_height))
    return x_within_bounds, y_within_bounds

# Main processing function
def process_ball_positions(file_path):
    positions = load_positions(file_path)
    print("Loaded Positions:", positions)

    # Calculate velocities
    velocities = calculate_velocities(positions)
    print("Velocities:", velocities)

    # Smooth positions and calculate errors
    smoothed_positions, smoothing_errors = smooth_positions(positions)
    print("Smoothing Errors:", smoothing_errors)

    # Calculate MSE for cluster consistency
    mse = calculate_mse(positions)
    print("Mean Squared Error (MSE):", mse)

    # Check boundaries
    x_bounds, y_bounds = check_boundaries(positions)
    print(f"X within bounds: {x_bounds}, Y within bounds: {y_bounds}")

    # Plot trajectories
    plot_trajectory(positions, smoothed_positions)

# File path to the uploaded file
file_path = '/content/sample_data/ball_path_data1.txt'  # Replace with your file path
process_ball_positions(file_path)

import numpy as np
import matplotlib.pyplot as plt

# Sample Data: Replace these with your actual data
velocities = np.array([247.00809703, 26., 24.41311123, 25.29822128, 23.34523506, 26.92582404,
                       31.01612484, 25.49509757, 28.44292531, 9.8488578, 12.64911064, 27.85677655,
                       22.02271555, 32.984845, 6.32455532, 25.96150997, 37.01351105, 42.43819035,
                       35.34119409, 39.92492956, 42.72001873, 42.95346319, 41.23105626, 43.46262762,
                       38.91015292, 38.94868419, 38.94868419, 34.13209633, 38.01315562, 31.40063694,
                       32.01562119, 28.60069929, 19.41648784, 25.07987241, 10.63014581, 6.08276253,
                       19.23538406, 32.64965543, 39.92492956, 12.80624847, 17., 20.1246118,
                       28.01785145, 33.24154028, 27.29468813, 27.45906044, 37.64306045, 29.61418579,
                       36.68787266, 33.54101966, 31.95309062, 34.20526275, 32.984845, 27.16615541,
                       23.19482701, 31.06444913, 24.08318916, 27.07397274, 26.07680962, 23.19482701,
                       51.0881591, 18.68154169, 10.77032961, 14.56021978, 18.86796226, 10.,
                       12.80624847, 17.02938637, 13.41640786, 11.70469991, 16.4924225, 19.31320792,
                       32.75667871, 24.69817807, 29.52964612, 35.34119409, 20.1246118, 23.60084744,
                       18.11077028, 26.2488095, 26.57066051, 26.47640459, 28.16025568, 35.0142828,
                       31.01612484, 38.05259518, 37.48332963, 36.68787266, 39.39543121, 41.62931659,
                       38.47076812, 41.34005322, 41.18252056, 39.11521443, 39.11521443, 29.61418579,
                       44.94441011, 120.83873551, 29.68164416])
smoothing_errors = np.array([151.05297084, 93.21480569, 46.17358552, 3.60555128, 3.16227766, 3.60555128,
                             2.82842712, 4.12310563, 7.28010989, 10.04987562, 1.41421356, 7.21110255,
                             14.14213562, 3.16227766, 14.76482306, 11.66190379, 13.45362405, 3.60555128,
                             6., 3.60555128, 2., 1.41421356, 1.41421356, 0., 3., 2.23606798, 2.,
                             3., 1.41421356, 4.12310563, 2.23606798, 4.24264069, 6.32455532, 6.32455532,
                             8.94427191, 5.38516481, 2.82842712, 13.03840481, 28.3019434, 6.40312424,
                             6.70820393, 5.38516481, 11.3137085, 6.70820393, 5.09901951, 4.12310563,
                             6.40312424, 1., 3.60555128, 3.16227766, 2., 2.82842712, 2.23606798,
                             5.65685425, 4.12310563, 3., 2.23606798, 1., 0., 7., 13.34166406,
                             20.61552813, 11.40175425, 2.23606798, 3.16227766, 4., 1.41421356, 3.16227766,
                             4.12310563, 2.23606798, 4.47213595, 10.19803903, 11.04536102, 6.40312424,
                             5.83095189, 1., 11.18033989, 4.12310563, 6.08276253, 5., 2.23606798,
                             2.23606798, 2.82842712, 3.16227766, 1., 3.60555128, 4., 4.47213595,
                             4., 1., 2.23606798, 2., 1., 2., 3.60555128, 14., 10.19803903,
                             48.27007354, 56.08921465])

# Calculate error between velocities and smoothed values
errors = np.abs(velocities - smoothing_errors)

# Simulating controller effect: for demonstration purposes, let's assume that the controller reduces errors by 10% at each step.
controller_effect = 0.9
error_with_controller = errors * controller_effect ** np.arange(len(errors))

# Plotting the errors
plt.figure(figsize=(12, 6))
plt.plot(errors, label='Real vs Smoothed Error', color='red')
plt.plot(error_with_controller, label='Error After Controller', color='blue', linestyle='--')
plt.title('Error Reduction Over Time with Controller')
plt.xlabel('Time Steps')
plt.ylabel('Error Magnitude')
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from scipy.integrate import odeint
import time

# PID Controller class
class PIDController:
    def __init__(self, Kp, Ki, Kd):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.prev_error = 0
        self.integral = 0

    def compute(self, setpoint, measured_value, dt):
        error = setpoint - measured_value
        self.integral += error * dt
        derivative = (error - self.prev_error) / dt
        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative
        self.prev_error = error
        return output

# Ball dynamics
def ball_dynamics(state, t, u_x, u_y):
    x, x_dot, y, y_dot = state  # positions and velocities
    g = 9.81  # gravity
    A = 5 / 7  # constant derived from ball's moment of inertia

    # Plate tilting angles controlled by PID outputs
    theta_x = u_x
    theta_y = u_y

    # Equations of motion
    x_ddot = A * g * np.sin(theta_x)
    y_ddot = A * g * np.sin(theta_y)

    return [x_dot, x_ddot, y_dot, y_ddot]

# Simulation function
def simulate_bps(setpoint_x, setpoint_y, t_max=10, dt=0.01):
    t = np.arange(0, t_max, dt)
    initial_state = [0.0, 0.0, 0.0, 0.0]  # Initial position and velocity

    pid_x = PIDController(Kp=1.2, Ki=0.0, Kd=0.5)  # PID for X-axis
    pid_y = PIDController(Kp=1.2, Ki=0.0, Kd=0.5)  # PID for Y-axis

    state = initial_state
    ball_positions = []
    control_signals = []

    for i in range(len(t)):
        u_x = pid_x.compute(setpoint_x, state[0], dt)  # PID output for X-axis
        u_y = pid_y.compute(setpoint_y, state[2], dt)  # PID output for Y-axis
        control_signals.append((u_x, u_y))

        # Simulate the system dynamics for the next step
        state = odeint(ball_dynamics, state, [0, dt], args=(u_x, u_y))[-1]

        # Store ball's positions (x, y)
        ball_positions.append((state[0], state[2]))

    return t, np.array(ball_positions), np.array(control_signals)

# Visualization and plotting
def visualize_bps(ball_positions, setpoint_x, setpoint_y):
    fig, ax = plt.subplots()

    ax.set_xlim(-1, 1)
    ax.set_ylim(-1, 1)
    ax.set_aspect('equal')
    ax.set_title('Ball on Plate Simulation')

    # Draw plate boundary
    plate = plt.Rectangle((-1, -1), 2, 2, fill=False, color='black')
    ax.add_patch(plate)

    # Create ball
    ball = Circle((0, 0), 0.05, color='blue')
    ax.add_patch(ball)

    # Desired position marker
    ax.plot(setpoint_x, setpoint_y, 'ro', label='Target Position')

    plt.ion()  # Enable interactive mode

    # Animate ball movement
    for pos in ball_positions:
        ball.center = pos
        plt.pause(0.01)  # Small delay for real-time feel

    plt.ioff()
    plt.show()

# Running the simulation and visualizing
setpoint_x = 0.5  # Desired X position
setpoint_y = 0.5  # Desired Y position

# Simulate the ball-on-plate system
t, ball_positions, control_signals = simulate_bps(setpoint_x, setpoint_y)

# Visualize the ball movement on the plate
visualize_bps(ball_positions, setpoint_x, setpoint_y)

# Plot the ball's trajectory (path) on the plate
def plot_ball_trajectory(ball_positions, setpoint_x, setpoint_y):
    fig, ax = plt.subplots()

    # Plot trajectory of the ball
    ax.plot(ball_positions[:, 0], ball_positions[:, 1], label='Ball Trajectory', color='blue')
    ax.plot(setpoint_x, setpoint_y, 'ro', label='Target Position')

    ax.set_xlim(-1, 1)
    ax.set_ylim(-1, 1)
    ax.set_aspect('equal')
    ax.set_title('Ball Trajectory on Plate')
    ax.legend()

    plt.show()

# Plot ball trajectory
plot_ball_trajectory(ball_positions, setpoint_x, setpoint_y)

# Calculate pixel distance error and settling time
def calculate_performance(ball_positions, setpoint_x, setpoint_y, tolerance=0.02):
    # Euclidean distance error between target and actual positions
    pixel_errors = np.sqrt((ball_positions[:, 0] - setpoint_x)**2 + (ball_positions[:, 1] - setpoint_y)**2)

    # Settling time: Time when error remains within the tolerance
    settling_time = None
    for i, error in enumerate(pixel_errors):
        if error < tolerance:
            if np.all(pixel_errors[i:] < tolerance):  # Check if it stays within tolerance
                settling_time = i * 0.01  # Time step is 0.01s
                break

    return pixel_errors, settling_time

# Calculate performance
pixel_errors, settling_time = calculate_performance(ball_positions, setpoint_x, setpoint_y)

# Plot pixel error over time
plt.figure()
plt.plot(t, pixel_errors)
plt.xlabel('Time (s)')
plt.ylabel('Pixel Distance Error')
plt.title('Pixel Error over Time')
plt.show()

# Display settling time
print(f"Settling time: {settling_time} seconds")

# Plot the control signals (PID outputs) over time
def plot_control_signals(control_signals, t):
    control_signals = np.array(control_signals)

    plt.figure()
    plt.plot(t, control_signals[:, 0], label='Control Signal X (Theta_x)', color='green')
    plt.plot(t, control_signals[:, 1], label='Control Signal Y (Theta_y)', color='purple')

    plt.xlabel('Time (s)')
    plt.ylabel('Control Signal (Tilt Angle)')
    plt.title('PID Control Signals Over Time')
    plt.legend()
    plt.show()

# Plot control signals
plot_control_signals(control_signals, t)





import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from scipy.linalg import solve_continuous_are

# Define the state-space model for the Ball-on-Plate system
def state_space_model(state, t, A, B, K, setpoint):
    x, x_dot, y, y_dot = state

    # State vector
    X = np.array([[x], [x_dot], [y], [y_dot]])

    # Setpoint (target position)
    target = np.array([[setpoint[0]], [0], [setpoint[1]], [0]])

    # LQR control law: u = -K * (X - target)
    u = -K @ (X - target)

    # State derivatives (dx/dt, ddx/dt)
    state_dot = A @ X + B @ u

    return [state_dot[0, 0], state_dot[1, 0], state_dot[2, 0], state_dot[3, 0]]

# Define the A and B matrices for the system (state-space)
g = 9.81  # gravity constant
A = np.array([[0, 1, 0, 0],  # dx/dt = x_dot
              [0, 0, 0, 0],  # ddx/dt = controlled by plate tilt in x-axis
              [0, 0, 0, 1],  # dy/dt = y_dot
              [0, 0, 0, 0]]) # ddy/dt = controlled by plate tilt in y-axis

B = np.array([[0, 0],
              [g, 0],  # x-axis controlled by tilt
              [0, 0],
              [0, g]])  # y-axis controlled by tilt

# Define Q and R matrices for the cost function
Q = np.array([[100, 0, 0, 0],  # Penalizing x position error heavily
              [0, 1, 0, 0],    # Penalizing x velocity less
              [0, 0, 100, 0],  # Penalizing y position error heavily
              [0, 0, 0, 1]])   # Penalizing y velocity less

R = np.array([[1, 0],  # Penalize control efforts (tilt angles)
              [0, 1]])

# Solve the continuous-time algebraic Riccati equation to get the matrix P
P = solve_continuous_are(A, B, Q, R)

# Calculate the optimal feedback gain matrix K
K = np.linalg.inv(R) @ B.T @ P

print("Optimal gain matrix K:\n", K)

# Simulation function with LQR
def simulate_lqr_bps(setpoint_x, setpoint_y, t_max=10, dt=0.01):
    t = np.arange(0, t_max, dt)
    initial_state = [0.0, 0.0, 0.0, 0.0]  # Initial position and velocity

    setpoint = [setpoint_x, setpoint_y]

    # Simulate the system over time using odeint
    state_trajectory = odeint(state_space_model, initial_state, t, args=(A, B, K, setpoint))

    ball_positions = state_trajectory[:, [0, 2]]  # Extract x, y positions

    return t, ball_positions

# Define desired positions for the ball
setpoint_x = 0.5  # Desired x-position
setpoint_y = 0.5  # Desired y-position

# Run the simulation
t, ball_positions = simulate_lqr_bps(setpoint_x, setpoint_y)

# Plot the ball trajectory
plt.figure()
plt.plot(ball_positions[:, 0], ball_positions[:, 1], label='Ball Trajectory')
plt.plot(setpoint_x, setpoint_y, 'ro', label='Target Position')
plt.xlim(-1, 1)
plt.ylim(-1, 1)
plt.title('Ball-on-Plate Trajectory using LQR')
plt.xlabel('X Position')
plt.ylabel('Y Position')
plt.legend()
plt.grid(True)
plt.show()

# Performance comparison: Calculate pixel errors and settling time for LQR
def calculate_lqr_performance(ball_positions, setpoint_x, setpoint_y, tolerance=0.02):
    pixel_errors = np.sqrt((ball_positions[:, 0] - setpoint_x)**2 + (ball_positions[:, 1] - setpoint_y)**2)

    settling_time = None
    for i, error in enumerate(pixel_errors):
        if error < tolerance:
            if np.all(pixel_errors[i:] < tolerance):
                settling_time = i * 0.01  # Time step is 0.01s
                break

    return pixel_errors, settling_time

# Calculate LQR performance
pixel_errors_lqr, settling_time_lqr = calculate_lqr_performance(ball_positions, setpoint_x, setpoint_y)

# Plot LQR pixel errors
plt.figure()
plt.plot(t, pixel_errors_lqr)
plt.xlabel('Time (s)')
plt.ylabel('Pixel Distance Error')
plt.title('LQR Pixel Error over Time')
plt.grid(True)
plt.show()

# Output settling time for LQR
print(f"Settling time for LQR: {settling_time_lqr} seconds")

import numpy as np
from scipy.linalg import solve_continuous_are

# Define matrices
A = np.array([[0, 1], [0, 0]])
B = np.array([[0], [7.07]])
Q = np.array([[100, 0], [0, 1]])  # Choose Q to prioritize position and velocity
R = np.array([[1]])  # Small weight on control effort

# Solve the Continuous Algebraic Riccati Equation
P = solve_continuous_are(A, B, Q, R)

# Compute the LQR gain K
K = np.linalg.inv(R) @ B.T @ P
print("LQR Gain K:", K)

